* Literate Configuration - How to use this file?
** Tangling and detangling
:PROPERTIES:
:header-args: :tangle yes
:END:

This is a small, dummy function to test if tangling works the way I expect it to
work.

#+BEGIN_SRC emacs-lisp
(defun +ccressent/my-little-function ()
  (interactive)
  (message "Hello there!"))
#+END_SRC

If a source block has the ~:comments link~ header, org-babel will include links
to the original block and it will then be possible to use ~org-babel-detangle~
on the generated file to propagate changes back to the original org file.

** Weaving

Weaving is the process of generating a human readable output from a literate
program. With org-mode files, this is achieved using org-export to export the
file to various formats.

* Org-mode buffers
:PROPERTIES:
:header-args: :tangle yes
:END:

There are some variables that I still need to figure out, such as:
- [[help:org-tags-column][org-tag-columns]]
- [[help:org-tag-alist][org-tag-alist]]
- [[help:org-todo-keywords][org-todo-keywords]]
- [[help:org-tag-persistent-alist][org-tag-persistent-alist]]

** Global variables

On all my machines, I store my notes in the ~notes~ folder of my home directory.
These notes are then synchronized between machines using [[https://syncthing.net/][Syncthing]].

When I capture something with a template that has no explicit target file, I
want it to go into the ~refile.org~ file: it holds entries I need to properly put
away somewhere else.

#+BEGIN_SRC emacs-lisp
(setq org-directory          (expand-file-name "~/notes/")
      org-default-notes-file (expand-file-name "refile.org" org-directory))
#+END_SRC

I also have a sub-directory where I keep small, self-organizing notes following
the [[https://en.wikipedia.org/wiki/Zettelkasten][Zettelkasten]] method, managed with the [[https://www.orgroam.com/][org-roam]] package.

#+BEGIN_SRC emacs-lisp
(setq org-roam-directory     (expand-file-name "zettelkasten" org-directory)
      org-roam-title-sources '((title headline) alias)
      org-roam-tag-sources   '(prop all-directories))
#+END_SRC

*** Disable ~smartparens~

I don't think automatically inserting the closing parenthesis, brackets, ... is
that useful when I'm writing text, and it messes with auto-completion when I
start writing some org-mode objects like ~[[~ and ~[[*~.

According to the author of smartparens, [[https://github.com/Fuco1/smartparens/issues/657][adding the mode to ~sp-ignore-modes-list~
is the correct approach.]]

#+BEGIN_SRC emacs-lisp
(after! smartparens
  (add-to-list 'sp-ignore-modes-list 'org-mode))
#+END_SRC

** Appearance

This section describes how things look in an org-mode buffer, even if the
underlying file is pure text.

When a section of a file is folded, an ellipsis marker is shown an the end of
the section header.

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " â¤µ")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Display [[https://orgmode.org/manual/Special-Symbols.html]["entities"]], such as \pi and \alpha, as UTF-8 characters. Similarly,
sub and superscript is displayed nicely, as long as the sub or super-scripted
text is enclosed in {}; e.g.: R_{t}, R^{2}.

The actual buffer content remains ASCII, this is purely for display purposes!
One can find a list of all available entities by calling ~org-entities-help~.

#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities t
      org-use-sub-superscripts '{})
#+END_SRC

** [[https://orgmode.org/manual/Images.html#Images][Image support]]

The [[help:org-startup-with-inline-images][org-startup-with-inline-images]] variable controls whether images should be
displayed inline when opening an org-mode file. This can also be toggled on/off
with [[help:org-toggle-inline-images][org-toggle-inline-images]].

#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images t)
#+END_SRC

** Capturing and refiling

See [[https://orgmode.org/manual/Capture-templates.html][the documentation for capture templates]] and [[https://orgmode.org/manual/Template-expansion.html#Template-expansion][template expansion]].
This is currently not picked up by Doom? It's probably being overwritten
somewhere.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
  '(("t" "todo" entry
     (file+headline "" "Tasks")
     "* TODO %?\n%i" :kill-buffer t)

    ("n" "note" entry
     (file+headline "" "Notes")
     "* %u %?\n%i" :kill-buffer t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((nil . (:maxlevel . 5))
                           (org-agenda-files . (:maxlevel . 5))))

;; When refiling, use the full org outline paths, prefixed by the file name, and
;; do not try to complete a path in hierarchical order: we use fuzzy matching to
;; find the right target.
(setq org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil)

;; Allow creation of new nodes when refiling, after confirmation.
(setq org-refile-allow-creating-parent-nodes 'confirm)

;; Add an advice to org-refile so that after a refile, all the org buffers get
;; automatically saved.
;;
;; An alternative approach could have been to use org-after-refile-insert-hook,
;; but while these functions are called after content is added to the refile
;; target, they are called _before_ the content is removed from the old
;; location, leaving the source buffer unsaved.
(advice-add 'org-refile :after 'org-save-all-org-buffers)
#+END_SRC

** Link Completion
*** Sensu specific issue/pr completion

Using org-mode's pluggable link completion, I've created functions to complete
links to Github issues and pull requests for Sensu, leveraging the information
that [[https://magit.vc/manual/forge/][forge]] fetches.

#+BEGIN_SRC emacs-lisp
(defun +ccressent/sensu-go-github-issue-pr-complete (&optional _)
  (let* ((forge-repo (forge-get-repository "https://github.com/sensu/sensu-go"))
         (forge-issue-url (forge--format forge-repo 'issue-url-format '((?i . "%s"))))
         (default-directory (oref forge-repo worktree)))
    (format forge-issue-url
            (forge-read-topic "Issue/PR"))))

(defun +ccressent/sensu-enterprise-go-github-issue-pr-complete (&optional _)
  (let* ((forge-repo (forge-get-repository "https://github.com/sensu/sensu-enterprise-go"))
         (forge-issue-url (forge--format forge-repo 'issue-url-format '((?i . "%s"))))
         (default-directory (oref forge-repo worktree)))
    (format forge-issue-url
            (forge-read-topic "Issue/PR"))))
#+END_SRC

This could be refactored and generalized to work for pretty much any repository
that [[https://magit.vc/manual/forge/][forge]] knows about. We then tell org to use these functions to complete
links of type ~sensu-go~ and ~sensu-enterprise-go~:

#+BEGIN_SRC emacs-lisp
(org-link-set-parameters "sensu-go"
                         :complete #'+ccressent/sensu-go-github-issue-pr-complete)
(org-link-set-parameters "sensu-enterprise-go"
                         :complete #'+ccressent/sensu-enterprise-go-github-issue-pr-complete)
 #+END_SRC

** Exporting
*** HTML

See: [[https://orgmode.org/manual/HTML-Export.html][HTML Export documentation]]

Org can export to various (X)HTML flavors, listed in ~org-html-doctype-alist~. One
picks a variant with the ~org-html-doctype~ variable. I choose HTML5 and allow the
exporter to use its new elements, like ~aside~ and ~video~. Note that this is
probably a bad idea in term of compatibility with older versions of Internet
Explorer.

#+BEGIN_SRC emacs-lisp
(setq org-html-doctype "html5"
      org-html-html5-fancy t)
#+END_SRC

*** [[https://cressent.org][cressent.org]]

In order to generate the HTML I want for [[https://cressent.org][cressent.org]], I've had to dig quite a
bit. I make use of filters, a custom export backend and a last pass of HTML
surgery to remove unwanted ~<div>~ elements. This seems quite heavy handed, but as
far as I can tell [[https://orgmode.org/manual/Advanced-Export-Configuration.html][from the manual]], this is the preferred approach.

Note that for what I wanted to do with footnotes, filters are enough because
they don't get access to the right context: a foonote-reference filter only gets
access to the reference text and it's not possible to access the corresponding
footnote definition. A footnote reference transcoder that we setup as part of a
custom backend, on the other hand, has access to enough context to fetch the
corresponding footnote definition.

First, we define a transcoder for footnote references that appends an ~<aside>~
element containing the corresponding footnote definition:

#+BEGIN_SRC emacs-lisp :results none
(defun cressent.org/transcode-footnote-ref (fn-ref _contents info)
  "Append the footnote definition after its reference, as an <aside> element.
The org-html-footnote-reference transcoder outputs the html for the reference,
and we append the definition after its result."
  (let ((number (org-export-get-footnote-number fn-ref info))
        (definition (org-export-data
                     (org-export-get-footnote-definition fn-ref info)
                     info)))
  (concat
   (org-html-footnote-reference fn-ref _contents info)
   (format "<aside class=\"sidenote\"><sup>%d</sup> %s</aside>"
           number definition))))
#+END_SRC

We use that footnote reference transcoder in a custom backend derived from the
html one. Additionally, we provide a function that can be used as the publish
function in a project:

#+BEGIN_SRC emacs-lisp :results none
(require 'ox)
(org-export-define-derived-backend 'cressent.org 'html
  :translate-alist '((footnote-reference . cressent.org/transcode-footnote-ref)))

(defun org-cressent.org-publish-to-html (plist filename pub-dir)
  "Publish an org file to HTML suitable for cressent.org.

PLIST is the property list for the given project. FILENAME is the file name of
the org file to be published. PUB-DIR is the publishing directory."
  (org-publish-org-to 'cressent.org filename
                      (concat "." (or (plist-get plist :html-extension)
                                      org-html-extension
                                      "html"))
                      plist
                      pub-dir))
#+END_SRC

Since we're only using that ~cressent.org~ backend with org-publish, we don't
bother creating an org-export menu entry for it, or any of the other user-facing
facilities that typical backends have.

Lastly, we need to do some HTML surgery to remove unwanted preamble and
postamble divs that the html backend automatically emits, with no way that I
could find to make it not do so:

#+BEGIN_SRC emacs-lisp :results none
(defun cressent.org/filter-final (input backend plist)
  (with-temp-buffer (sgml-mode)
    (insert input)
    (goto-char (point-min))

    (when (search-forward "<div id=\"preamble\"" nil t)
      (sgml-delete-tag 1))

    (when (search-forward "<div id=\"postamble\"" nil t)
      (sgml-delete-tag 1))

    (buffer-string)))

;; This should only be done in the context of exporting with the cressent.org
;; backend instead of globally!
(setq org-export-filter-final-output-functions '(cressent.org/filter-final))
#+END_SRC

** Publishing

This section deals with my ~org-publish~ configuration, mainly used to publish
[[https://cressent.org][cressent.org]].

#+BEGIN_SRC emacs-lisp :results none
(setq cressent.org/page-header '(("en" "
<header>
  <div class=\"title\">
    <h1><a href=\"/\">cressent.org</a></h1>
    <h2>%t</h2>
  </div>
  <nav>
    <ul>
      <li><a href=\"/\">Home</a></li>
      <!-- <li><a href=\"tags\">Tags</a></li> -->
      <!-- <li><a href=\"feed\">Feed</a></li> -->
      <li><a href=\"about\">About</a></li>
    </ul>
  </nav>
</header>

<article>
  <header>
    <h1>%t</h1>
    <div class=\"article-meta\">
      <div>
        <p>published <time datetime=\"%d\">%d</time></p>
        <p>updated <time datetime=\"%C\">%C</time></p>
      </div>
      <div>
        <!-- Tags will go here -->
      </div>
    </div>
  </header>
")))

(setq cressent.org/page-footer '(("en" "
</article>

<footer>
  <p>
    Feel free to <a href=\"about\"> get in touch</a>.
  <p/>
  <!-- Link to org file source and mention git commit? -->
</footer>
")))

(setq org-publish-project-alist
      `(
        ("cressent.org" :components ("cressent.org - org content"
                                     "cressent.org - static files"))

        ("cressent.org - org content"
         :base-directory "~/src/ccressent/cressent.org/src"
         :base-extension "org"
         :recursive t
         :publishing-directory "~/src/ccressent/cressent.org/dist"
         :publishing-function org-cressent.org-publish-to-html

         :headline-levels 4
         :html-self-link-headlines t

         ;; We take care of the title in the preamble, so no need to include it
         ;; again.
         :with-title nil
         :with-footnotes t
         :with-toc t
         :html-container "section"
         :section-numbers nil

         :html-metadata-timestamp-format "%Y-%m-%d"

         :html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"../css/main.css\" />"
         :html-head-include-scripts nil
         :html-head-include-default-style nil

         :html-preamble t
         :html-preamble-format ,cressent.org/page-header

         :html-postamble t
         :html-postamble-format ,cressent.org/page-footer)

        ("cressent.org - static files"
         :base-directory "~/src/ccressent/cressent.org/src"
         :base-extension "html\\|css\\|js\\|png\\|jpg\\|svg\\|gif\\|pdf\\|woff"
         :recursive t
         :publishing-directory "~/src/ccressent/cressent.org/dist"
         :publishing-function org-publish-attachment)
      ))
#+END_SRC

Note that one can tell Emacs to publish a project directly from the command
line if needed:
#+BEGIN_SRC sh
emacs --eval '(progn (org-publish-project "cressent.org") (kill-emacs))'
#+END_SRC

* Agenda
:PROPERTIES:
:header-args: :tangle yes
:END:

** Global variables

With proper custom agenda views and filtering, it should be fine to just include
all my org files in the agenda. This hasn't caused me any issues yet. This might
change with my growing ~org-directory/zettelkasten~ sub-directory though. See the
documentation for ~directory-files-recursively~ to make it ignore some
directories.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (directory-files-recursively org-directory "\.org$"))
#+END_SRC

Displaying the agenda window might alter the current window configuration. With
the ~org-agenda-restore-windows-after-quit~ variable set to ~t~, the window
state will be saved before displaying the agenda and then restored after the
agenda is exited.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-restore-windows-after-quit t)
#+END_SRC

I like my default agenda view to span 7 days, showing the 2 previous days, the
current day and the next 4 days.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-start-on-weekday nil
      org-agenda-span 'week
      org-agenda-start-day "-2d")
#+END_SRC

*** org-super-agenda

The [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] package lets one easily group agenda items into sections.
The repository is well documented and has quite a [[https://github.com/alphapapa/org-super-agenda/blob/master/examples.org][lot of examples]]!

#+BEGIN_SRC emacs-lisp
(use-package! org-super-agenda
    :after org-agenda
    :config (org-super-agenda-mode))
#+END_SRC

We define the various groupings through the ~org-super-agenda-groups~ variable:

#+BEGIN_SRC emacs-lisp
(setq org-super-agenda-groups '((:name none
                                       :time-grid t)
                                (:name "High Priority"
                                       :priority "A"
                                       :tag "bills")
                                (:name "Work"
                                       :and (:scheduled today :tag "work"))
                                (:name "Other"
                                       :scheduled today)
                                (:name "Due today"
                                       :deadline today)
                                (:name "Due soon"
                                       :deadline future)
                                (:name "Reschedule"
                                       :scheduled past)
                                (:order-multi (1 (:name "Done today"
                                                  :and (:regexp "State \"DONE\""
                                                        :log t))
                                                 (:name "Clocked today"
                                                        :log t)))
                                (:name "Waiting"
                                       :todo ("WAIT" "WAITING")
                                       :order 98)))
#+END_SRC

The package is not "evilified" so there are some keymap issues. Setting some of
the package's keybind maps to ~nil~ serves as a quick fix, but the real fix would
be to properly redefine the keymaps with vi-like bindings, as needed.

#+BEGIN_SRC emacs-lisp
(setq org-super-agenda-header-map nil)
#+END_SRC

** The agenda view

In the agenda view, every single day, even if there are no associated tasks, are
displayed. This lets me see days I currently have "free".

#+BEGIN_SRC emacs-lisp
(setq org-agenda-show-all-dates t)
#+END_SRC

Whenever the agenda displays a single day or if the current day is part of what
is being displayed, I want to see a time grid detailing that day, spanning from
8am to 10pm.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-time-grid '((daily today remove-match)
                             (0800 1000 1200 1400 1600 1800 2000 2200)
                             "......"
                             "----------------"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '((" " "Agenda"
         ((agenda "" nil)
          (tags "REFILE"
                ((org-agenda-overriding-header "Nodes to refile")
                 (org-tags-match-list-sublevels t)))))))
#+END_SRC

~org-agenda-compact-blocks~ makes the agenda more compact by removing empty lines
between sections, week number, ...

#+BEGIN_SRC elisp
(setq org-agenda-compact-blocks t)
#+END_SRC

I want the agenda to warn me about a coming deadline, but if a task with a
deadline has been scheduled, no need to display the deadline approaching
pre-warning in the agenda view; if I have it scheduled, I should take care of it
on that day.

~org-agenda-skip-deadline-if-done~ is rather badly named: it only applies to the
current day. I set it so that even completed deadlines show on the day they are
due, as a reminder in case I've accidentally marked the task as done but still
need to take some action related to it on that day, like submitting something or
calling someone.

#+BEGIN_SRC elisp
(setq org-deadline-warning-days 14
      org-agenda-skip-deadline-if-done nil
      org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
#+END_SRC
