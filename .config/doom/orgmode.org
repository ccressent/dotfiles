* Literate Configuration - How to use this file?
** Tangling and detangling
:PROPERTIES:
:header-args: :tangle yes
:END:

This is a small, dummy function to test if tangling works the way I expect it to
work.

#+BEGIN_SRC emacs-lisp
(defun +ccressent/my-little-function ()
  (interactive)
  (message "Hello there!"))
#+END_SRC

If a source block has the ~:comments link~ header, org-babel will include links
to the original block and it will then be possible to use ~org-babel-detangle~
on the generated file to propagate changes back to the original org file.

** Weaving

Weaving is the process of generating a human readable output from a literate
program. With org-mode files, this is achieved using org-export to export the
file to various formats.

* Org-mode buffers
:PROPERTIES:
:header-args: :tangle yes
:END:

There are some variables that I still need to figure out, such as:
- [[help:org-tags-column][org-tag-columns]]
- [[help:org-tag-alist][org-tag-alist]]
- [[help:org-todo-keywords][org-todo-keywords]]
- [[help:org-tag-persistent-alist][org-tag-persistent-alist]]

** Global variables

On all my machines, I store my notes in the ~notes~ folder of my home directory.
These notes are then synchronized between machines using [[https://syncthing.net/][Syncthing]].

When I capture something with a template that has no explicit target file, I
want it to go into the ~refile.org~ file: it holds entries I need to properly put
away somewhere else.

#+BEGIN_SRC emacs-lisp
(setq org-directory          (expand-file-name "~/notes/")
      org-default-notes-file (expand-file-name "refile.org" org-directory))
#+END_SRC

I also have a sub-directory where I keep small, self-organizing notes following
the [[https://en.wikipedia.org/wiki/Zettelkasten][Zettelkasten]] method, managed with the [[https://www.orgroam.com/][org-roam]] package.

#+BEGIN_SRC emacs-lisp
(setq org-roam-directory     (expand-file-name "zettelkasten" org-directory)
      org-roam-title-sources '((title headline) alias)
      org-roam-tag-sources   '(prop all-directories))
#+END_SRC

*** Disable ~smartparens~

I don't think automatically inserting the closing parenthesis, brackets, ... is
that useful when I'm writing text, and it messes with auto-completion when I
start writing some org-mode objects like ~[[~ and ~[[*~.

According to the author of smartparens, [[https://github.com/Fuco1/smartparens/issues/657][adding the mode to ~sp-ignore-modes-list~
is the correct approach.]]

#+BEGIN_SRC emacs-lisp
(after! smartparens
  (add-to-list 'sp-ignore-modes-list 'org-mode))
#+END_SRC

** Appearance

This section describes how things look in an org-mode buffer, even if the
underlying file is pure text.

When a section of a file is folded, an ellipsis marker is shown an the end of
the section header.

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " â¤µ")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Display [[https://orgmode.org/manual/Special-Symbols.html]["entities"]], such as \pi and \alpha, as UTF-8 characters. Similarly,
sub and superscript is displayed nicely, as long as the sub or super-scripted
text is enclosed in {}; e.g.: R_{t}, R^{2}.

The actual buffer content remains ASCII, this is purely for display purposes!
One can find a list of all available entities by calling ~org-entities-help~.

#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities t
      org-use-sub-superscripts '{})
#+END_SRC

** [[https://orgmode.org/manual/Images.html#Images][Image support]]

The [[help:org-startup-with-inline-images][org-startup-with-inline-images]] variable controls whether images should be
displayed inline when opening an org-mode file. This can also be toggled on/off
with [[help:org-toggle-inline-images][org-toggle-inline-images]].

#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images t)
#+END_SRC

** Capturing and refiling

See [[https://orgmode.org/manual/Capture-templates.html][the documentation for capture templates]] and [[https://orgmode.org/manual/Template-expansion.html#Template-expansion][template expansion]].
This is currently not picked up by Doom? It's probably being overwritten
somewhere.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
  '(("t" "todo" entry
     (file+headline "" "Tasks")
     "* TODO %?\n%i" :kill-buffer t)

    ("n" "note" entry
     (file+headline "" "Notes")
     "* %u %?\n%i" :kill-buffer t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((nil . (:maxlevel . 5))
                           (org-agenda-files . (:maxlevel . 5))))

;; When refiling, use the full org outline paths, prefixed by the file name, and
;; do not try to complete a path in hierarchical order: we use fuzzy matching to
;; find the right target.
(setq org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil)

;; Allow creation of new nodes when refiling, after confirmation.
(setq org-refile-allow-creating-parent-nodes 'confirm)

;; Add an advice to org-refile so that after a refile, all the org buffers get
;; automatically saved.
;;
;; An alternative approach could have been to use org-after-refile-insert-hook,
;; but while these functions are called after content is added to the refile
;; target, they are called _before_ the content is removed from the old
;; location, leaving the source buffer unsaved.
(advice-add 'org-refile :after 'org-save-all-org-buffers)
#+END_SRC

** Link Completion
*** Sensu specific issue/pr completion

Using org-mode's pluggable link completion, I've created functions to complete
links to Github issues and pull requests for Sensu, leveraging the information
that [[https://magit.vc/manual/forge/][forge]] fetches.

#+BEGIN_SRC emacs-lisp
(defun +ccressent/sensu-go-github-issue-pr-complete (&optional _)
  (let* ((forge-repo (forge-get-repository "https://github.com/sensu/sensu-go"))
         (forge-issue-url (forge--format forge-repo 'issue-url-format '((?i . "%s"))))
         (default-directory (oref forge-repo worktree)))
    (format forge-issue-url
            (forge-read-topic "Issue/PR"))))

(defun +ccressent/sensu-enterprise-go-github-issue-pr-complete (&optional _)
  (let* ((forge-repo (forge-get-repository "https://github.com/sensu/sensu-enterprise-go"))
         (forge-issue-url (forge--format forge-repo 'issue-url-format '((?i . "%s"))))
         (default-directory (oref forge-repo worktree)))
    (format forge-issue-url
            (forge-read-topic "Issue/PR"))))
#+END_SRC

This could be refactored and generalized to work for pretty much any repository
that [[https://magit.vc/manual/forge/][forge]] knows about. We then tell org to use these functions to complete
links of type ~sensu-go~ and ~sensu-enterprise-go~:

#+BEGIN_SRC emacs-lisp
(org-link-set-parameters "sensu-go"
                         :complete #'+ccressent/sensu-go-github-issue-pr-complete)
(org-link-set-parameters "sensu-enterprise-go"
                         :complete #'+ccressent/sensu-enterprise-go-github-issue-pr-complete)
 #+END_SRC

** Exporting
*** HTML

See: [[https://orgmode.org/manual/HTML-Export.html][HTML Export documentation]]

Org can export to various (X)HTML flavors, listed in ~org-html-doctype-alist~. One
picks a variant with the ~org-html-doctype~ variable. I choose HTML5 and allow the
exporter to use its new elements, like ~aside~ and ~video~. Note that this is
probably a bad idea in term of compatibility with older versions of Internet
Explorer.

#+BEGIN_SRC emacs-lisp
(setq org-html-doctype "html5"
      org-html-html5-fancy t)
#+END_SRC

* Agenda
:PROPERTIES:
:header-args: :tangle yes
:END:

** Global variables

With proper custom agenda views and filtering, it should be fine to just include
all my org files in the agenda. This hasn't caused me any issues yet. This might
change with my growing ~org-directory/zettelkasten~ sub-directory though. See the
documentation for ~directory-files-recursively~ to make it ignore some
directories.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (directory-files-recursively org-directory "\.org$"))
#+END_SRC

Displaying the agenda window might alter the current window configuration. With
the ~org-agenda-restore-windows-after-quit~ variable set to ~t~, the window
state will be saved before displaying the agenda and then restored after the
agenda is exited.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-restore-windows-after-quit t)
#+END_SRC

I like my default agenda view to span 7 days, showing the 2 previous days, the
current day and the next 4 days.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-start-on-weekday nil
      org-agenda-span 'week
      org-agenda-start-day "-2d")
#+END_SRC

*** org-super-agenda

The [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] package lets one easily group agenda items into sections.
The repository is well documented and has quite a [[https://github.com/alphapapa/org-super-agenda/blob/master/examples.org][lot of examples]]!

#+BEGIN_SRC emacs-lisp
(use-package! org-super-agenda
    :after org-agenda
    :config (org-super-agenda-mode))
#+END_SRC

We define the various groupings through the ~org-super-agenda-groups~ variable:

#+BEGIN_SRC emacs-lisp
(setq org-super-agenda-groups '((:name none
                                       :time-grid t)
                                (:name "High Priority"
                                       :priority "A"
                                       :tag "bills")
                                (:name "Work"
                                       :and (:scheduled today :tag "work"))
                                (:name "Other"
                                       :scheduled today)
                                (:name "Due today"
                                       :deadline today)
                                (:name "Due soon"
                                       :deadline future)
                                (:name "Reschedule"
                                       :scheduled past)
                                (:order-multi (1 (:name "Done today"
                                                  :and (:regexp "State \"DONE\""
                                                        :log t))
                                                 (:name "Clocked today"
                                                        :log t)))
                                (:name "Waiting"
                                       :todo ("WAIT" "WAITING")
                                       :order 98)))
#+END_SRC

The package is not "evilified" so there are some keymap issues. Setting some of
the package's keybind maps to ~nil~ serves as a quick fix, but the real fix would
be to properly redefine the keymaps with vi-like bindings, as needed.

#+BEGIN_SRC emacs-lisp
(setq org-super-agenda-header-map nil)
#+END_SRC

** The agenda view

In the agenda view, every single day, even if there are no associated tasks, are
displayed. This lets me see days I currently have "free".

#+BEGIN_SRC emacs-lisp
(setq org-agenda-show-all-dates t)
#+END_SRC

Whenever the agenda displays a single day or if the current day is part of what
is being displayed, I want to see a time grid detailing that day, spanning from
8am to 10pm.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-time-grid '((daily today remove-match)
                             (0800 1000 1200 1400 1600 1800 2000 2200)
                             "......"
                             "----------------"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '((" " "Agenda"
         ((agenda "" nil)
          (tags "REFILE"
                ((org-agenda-overriding-header "Nodes to refile")
                 (org-tags-match-list-sublevels t)))))))
#+END_SRC

~org-agenda-compact-blocks~ makes the agenda more compact by removing empty lines
between sections, week number, ...

#+BEGIN_SRC elisp
(setq org-agenda-compact-blocks t)
#+END_SRC

I want the agenda to warn me about a coming deadline, but if a task with a
deadline has been scheduled, no need to display the deadline approaching
pre-warning in the agenda view; if I have it scheduled, I should take care of it
on that day.

~org-agenda-skip-deadline-if-done~ is rather badly named: it only applies to the
current day. I set it so that even completed deadlines show on the day they are
due, as a reminder in case I've accidentally marked the task as done but still
need to take some action related to it on that day, like submitting something or
calling someone.

#+BEGIN_SRC elisp
(setq org-deadline-warning-days 14
      org-agenda-skip-deadline-if-done nil
      org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
#+END_SRC
